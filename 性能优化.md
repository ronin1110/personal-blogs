# 性能优化

 先从“输入 URL 到页面呈现” 这个知识点着手讲起。

1. DNS解析
2. TCP连接
3. 发送http请求
4. 服务器响应
5. 浏览器渲染页面

## DNS解析

这里其实没啥操作空间（对于前端来说）

DNS解析的顺序

浏览器DNS缓存-》系统缓存-》路由器缓存-》本地服务器-》……-》顶级域名服务器

先忽略



## TCP连接

熟悉三次握手四次挥手

跳过



## 发送HTTP请求

- 利用浏览器缓存
  看采用强缓存还是协商缓存，加快页面加载
- Cookie和WebStorage
  还是对一些数据进行缓存，方便使用
- CDN的使用
  静态资源的请求可以采用CDN，减轻服务器压力
- 负载均衡
  我知道的就是反向代理，分摊服务器压力，（顺带提一嘴，正向代理是代理客户端，反向代理是代理服务器）

## 服务器响应

- Webpack优化
  也就是对发布的项目进行打包优化，按需加载，tree shaking（去掉无用的代码），还有一些用包的min版就不提了

- > 图片优化我们需要熟悉了解 `JPG/JPEG`、`PNG-8/PNG-24`、`GIF`、`Base64`、`SVG` 这些图片的特性，然后通过 Webpack 的 `url-loader` 将一些小图标转换成 `Base64`，一些 Icon 使用 `SVG`，一些轮播图、Banner 图用 `JPG/JPGE`、雪碧图的使用等。

- Gzip压缩
  注意需要用到Gzip的场景是项目比较大的时候，（Gzip的原理就是替换重复出现的字符串，项目小就没有必要），通过Webpack的ComparessionPlugin进行Gzip压缩，然后在Nginx进行配置，就能用好Gzip了

- 服务端渲染（SSR）
  就是在服务端做好渲染工作，直接将渲染好的html文件返回给浏览器，浏览器直接渲染就好，减少前后端交互，对SEO更友好。

## 浏览器解析渲染页面

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d1aa59771f8459e81a983d4310bedf8~tplv-k3u1fbpfcp-watermark.image)

网上偷的图

一步步来

1. 解析html，生成DOM树
2. 解析css文件，生成css规则树
3. 将DOM树与CSS树结合，生成渲染树（Render tree）
4. 从根节点开始，计算每一个元素的大小、位置，给出每个节点所应该出现的屏幕精确坐标，从而得到基于渲染树的 **布局渲染树**（Layout of the render tree）。
5. 遍历渲染树，将每个节点用UI渲染引擎绘制出来，这个步骤叫做**绘制渲染树**

正对上面的步骤，可以优化的地方有

1. CSS选择器解析的问题，编码过程中净可能少的选择器来选择一个元素，CSS从右往左加载（之前有写过）
2. CSS加载的位置，净可能在head中加载css，减少HTML的加载完等待css加载的问题
3. js加载的问题。我们知道js线程会阻塞HTML与CSS的加载，所以为了用户体验，我们把script标签放在body的最后，同时可以使用script的async和defer属性，同步或异步加载（async与defer都是遇到直接下载，差别在执行的时候，两者都没有的时候，遇到js文件直接下载执行，有**async**的时候，会立即下载，文档解析完后再执行，有defer的时候，js立即下载，文档解析不会停，下载完后，立即执行，文档解析会停止等js结束）
4. 到了DOM渲染的时候，减少重排和重绘（之前有写过）



## 其他

主要是一些预加载或者懒加载之类的



# 浏览器缓存

之前有整理过

# Cookie，Session，LocalStorage，SessionStorage

之前也有整理过



# CDN

CDN（Content Delivery Network，内容分发网络）指的是一组分布在各个地区的服务器

CDN 的核心：**缓存** 和 **回源**。

- **缓存**：将资源 `copy` 一份到 CDN 服务器。
- **回源**：CDN 发现自己没有这个资源，转头向根服务器（上级服务器）请求这个资源。



# 负载均衡

我了解的只有：`Nginx`：通过轮询机制，将用户的请求分配到压力较小的服务器上（反向代理，弱化具体服务器概念）。



# WebPack优化

没怎么看，容我看完视频再整理



# 服务端渲染

## 是什么

客户端渲染中，页面上呈现的内容，在 HTML 源文件中往往找不到。

服务端渲染的时候，服务器会把页面渲染成HTML字符串，返回给客户端

也就是渲染计算的过程发生在服务端，客户端不需要运行js代码去计算页面DOM内容

服务端渲染中，页面呈现的内容在HTML源文件中都可以找到，（就是个html文本文件）



## 为什么

服务端渲染

1. 是可以有更好的SEO体验，因为可以直接把现成的页面内容给搜索引擎看。方便搜索到。
2. 解决首屏加载慢的问题：因为科幻短渲染的过程中，需要很多步骤，解析各种HTML，CSS，js文件都需要时间。生成渲染树也需要时间。

## 如何使用

8了解

## 小结

SSR 主要用于解决单页应用首屏渲染慢以及 SEO 问题，同时也解决了与后端同学的沟通成本。但同时：提高了服务器压力，吃 CPU，内存等资源，优化不好提高成本。



# 浏览器渲染

之前做过整理

# 预加载

`preload` 提供了一种声明式的命令，让浏览器提前加载指定资源（加载后并不执行），在需要执行的时候再执行。

```html
<link rel="preload" href="/path/to/style.css" as="style">
```

好处：

1. 加载和执行分开，可以不阻塞document的onload事件
2. 提前加载指定资源，不再出现依赖的 `font` 字体隔了一段时间才刷出

在不支持 `preload` 的浏览器环境中，会忽略对应的 `link` 标签。

区分 `preload` 和 `prefetch`：

- `preload`：告诉浏览器页面必定需要的资源，浏览器一定会加载这些资源。
- `prefetch`：告诉浏览器页面可能需要的资源，浏览器不一定会加载这些资源。



# 懒加载

进入可视化的区域的时候才进行加载

方法：

1. 可以通过监听scroll事件，比较元素位置距离所在具体页面窗口的距离，赋予img标签src，加载图片资源。
2. img标签自带的loading属性：loading
   lazy:懒惰装载。
   eager:立即装载。
   auto: 浏览器将决定是否延迟加载。
3. IntersectionObserver（没了解）





